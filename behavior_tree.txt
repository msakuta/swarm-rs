tree main = Sequence {
    var fight = false
    Print(input <- "Resetting fight")
    Repeat (n <- "10000") {
        if (fight) {
            # Print(input <- "Fighting")
            Fight
        } else {
            ForceSuccess {
                GatherResource(switchToFight -> fight)
            }
            #Print(input <- "Got fight = {}", arg0 <- fight)
            if (fight) {
                ClearPath
                ForceSuccess {
                    ClearTarget
                }
            }
        }
    }
}

tree Fight = Sequence {
    if (!HasTarget) {
        FindEnemy
    }
    ForceSuccess {
        if (TargetPos (pos -> targetPos) && IsTargetVisible (target <- targetPos)) {
            FaceToTarget (target <- targetPos)
            Shoot
        } else {
            FollowPathAndAvoid
        }
    }
}

tree GatherResource(out switchToFight) = Sequence {
    if (IsSpawnerResourceFull) {
        SetBool(value <- "true", output -> switchToFight)
        !Print(input <- "Set swithToFight = {}", arg0 <- switchToFight)
    }
    if (IsResourceFull) {
        FindSpawner
        FollowPathAndAvoid
        DepositResource
    } else {
        #if (!HasTarget) {
            FindResource
        #}
        FollowPathAndAvoid
        CollectResource
    }
}

tree TryReverse = ReactiveSequence {
    # Try to revese in an attempt to "unstack"
    Drive (direction <- "backward")
    Randomize (max <- "20", value -> timeoutValue)
    Timeout (time <- timeoutValue)
}

tree FollowPathAndAvoid = Sequence {
    TargetPos (pos -> target_pos)
    if (!HasPath) {
        if (!FindPath (target <- target_pos, fail_reason -> failReason)) {
            Print (input <- "Failed to find path! reason: {}", arg0 <- failReason)
            # If path finding failed because the start is blocked, try back out
            if (StringEq(lhs <- failReason, rhs <- "StartBlocked")) {
                TryReverse
            }
        }
    }
    if (HasPath) {
        #SimpleAvoidance
        if (!FollowPath) {
            Print (input <- "Blocked, finding path")
            TryReverse
            # Find path again if blocked
            FindPath (target <- target_pos)
            #AvoidancePlan
        }
    }
}

tree AvoidancePlan = Sequence {
    if (PathNextNode (output -> pathNext)) {
        Randomize (min <- "20", max <- "100", value -> timeoutValue)
        ReactiveFallback {
            Avoidance (goal <- pathNext)
            ForceFailure {
                Timeout (time <- timeoutValue)
            }
            ClearAvoidance
        }
    }
}
